generic specification
  parameter elem
  using nat, set-ext

target

sorts map;

constants
  ∅: map;
    comment: empty-map constructor;

functions
  . |-> .  : elem × elem → map;
    comment: single-element map constructor;
  . ⊕ .    : map × map → map;
    comment: map-union constructor;

  count    : map × elem × elem → nat;
    comment: used for extensionality axiom;
  keyCount : map × elem → nat;
    comment: used for legal predicate;

  keys     : map → set;
    comment: projects map on keys;
  values   : map → set;
    comment: projects map on values;

  kvCount  : map × elem × set → nat;
    comment: local helper function for some proofs;

predicates
  legal    : map;
    comment: distinguishes legal maps from illegal (key, value)-bags;
  . ⊆ .    : map × map;
    comment: subset relation on arbitrary (key, value)-bags;

  haskey   : elem × map;
    comment: checks for existence of a key;
  hasvalue : elem × map; 
    comment: checks for existence of a value;

variables map, map0, map1, map2, map3: map;
  d: elem;

induction map generated by ∅, |->, ⊕;

axioms
  extension:        map1 = map2 ↔ ∀ a, b . count(map1, a, b) = count(map2, a, b);
  subset:           map1 ⊆ map2 ↔ ∀ a, b . count(map1, a, b) ≤ count(map2, a, b);
  legal:            legal(map) ↔ ∀ a . keyCount(map, a) ≤ 1;                            used for: ls;

  count-empty:      count(∅, a, b) = 0;                                                 used for: s, ls;
  count-single1:    count(a |-> b, a, b) = 1;                                           used for: s, ls;
  count-single2:    a ≠ c ⊦ count(c |-> d, a, b) = 0;                                   used for: s, ls;
  count-single3:    b ≠ d ⊦ count(a |-> d, a, b) = 0;                                   used for: s, ls;
  count-plus:       count(map1 ⊕ map2, a, b) = count(map1, a, b) + count(map2, a, b);   used for: s, ls;

  keyCount-empty:   keyCount(∅, a) = 0;                                                 used for: s, ls;
  keyCount-single1: keyCount(a |-> b, a) = 1;                                           used for: s, ls;
  keyCount-single2: a ≠ c ⊦ keyCount(c |-> b, a) = 0;                                   used for: s, ls;
  keyCount-plus:    keyCount(map1 ⊕ map2, a) = keyCount(map1, a) + keyCount(map2, a);   used for: s, ls;

  keys-empty:       keys(∅) = ∅;                                                        used for: s, ls;
  keys-single:      keys(a |-> b) = { a };                                              used for: s, ls;
  keys-plus:        keys(map1 ⊕ map2) = keys(map1) ∪ keys(map2);                        used for: s, ls;

  values-empty:     values(∅) = ∅;                                                      used for: s, ls;
  values-single:    values(a |-> b) = { b };                                            used for: s, ls;
  values-plus:      values(map1 ⊕ map2) = values(map1) ∪ values(map2);                  used for: s, ls;

  haskey-def:       haskey(a, map)   ↔ a ∈ keys(map);                                   used for: s, ls;
  hasvalue-def:     hasvalue(a, map) ↔ a ∈ values(map);                                 used for: s, ls;

  kvCount-empty:    kvCount(map, a, ∅) = 0;                                             used for: ls;
  kvCount-rec:      kvCount(map, a, s ++ b) = count(map, a, b) + kvCount(map, a, s);    used for: ls;
end generic specification